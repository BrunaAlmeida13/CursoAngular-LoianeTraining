> Para os components de um módulo funcional, serem lidos pelo módulo principal, exports o módulo funcional e o import no módulo raíz.
> Tudo que estiver declarado no exports do módulo funcional, consegue-se usar em qualquer component declarado em declarations no módulo raíz. 

> Serviços
 - Normalmente quando se faz uma listagem de dados, tem de ser de forma dinâmica, pois os dados vêm de um servidor
 - É uma má prática deixar o código para, por exemplo, fazer a chamada do servidor, dentro do component
 - O código que vai dentro do component vai ser responsável pela lógica que vai mostrar os dados, e interagir com o usuário (ex. onClick)

 > Plugins para baixar:
 => Angular 2, 4, and upcoming latest TypeScript
 => Angular Snnipets
 => HTML Snnipets

 ---------------------------------------------------------------------------------------------------------------

> Propety Binding + interpolação 
- É uma forma de associar informações que estão no component para o template e vice-versa. Ou seja, se se tem uma variável, atributo ou método que retorna um valor, consegue-se mostrar essas informações em um template. E quando um usuário interage com o HTML, nesse caso serão disparados alguns eventos, e eles poderão ser escutados em um component, o qual realizará uma lógica correspondente.
- Existem 4 formas de fazer o databind 
    1. Interpolation 
        {{ valor }}
        Pega o valor de um atributo ou método e se consegue ter a saída dessa informação no template.
    
    2. Propety Binding (associação de propriedade) 
        [propriedade]="valor"
        Não precisa usar as chaves, pois os colchetes são interpretados como databinding
        Quando não existe uma propriedade no elemento usa-se [attr.colspan]
    
    e no contrário...
   
    3. (evento)="handler"
        Quando se escuta o evento no template (ex.: clique no botão, foco no input)
    
    4. To-way DataBing
        [(ngModel)]="propriedade"    
        Aqui se consegue manter o template e o component atualizados ao mesmo tempo, e isso é útil ao trabalhar com formulários

- O angular consegue resolver expressões (matemática, booleana) dentro da interpolação também.

> Class e Style binding (Binding de classes e estilos)
- Tambem são uma forma de property binding, no lugar de trabalhar com variáveis ou expressões, se trabalha com css

>>> Para utilizar o css na aplicação, pode-se usar o bootstrap
npm install ng2-bootstrap bootstrap --save
e no arquivo angular.json, em styles import "../node_modules/bootstrap/dist/css/bootstrap.min.css" <<<

> Event Binding
- No property binding se usa () ao invés de []
- Também é possível fazer um style in line, como se faz com o template:
   ex. styles: [
            `
                .highlight {
                    background-color: yellow;
                    font-weight: bold;
                }
            `
        ]

> To-Way data Binding
- Bind bidirecional
- Atualizando o template e o componente ao mesmo tempo
- Para fazer esse uso simultâneo, é necessário usar binding de eventos + propriedades
- Quando se está trabalhando com to-way data binding, usa-se o ngModel, que é uma diretiva que pertence ao módulo formsModule, o qual já vem automaticamente importado no app.module. Então se o component estiver declarado no app module, não precisa importar de novo.

>>> Funcionamento angular
-> Quando a pasta está no contexto app, e se quer usar o component em outro componente funcional, se declara o component em declarations em NgModule, e importa o módulo do componente.
-- OBS.: E para o component ser usado/importado, seu módulo terá de ser exportado: exports 
E quando for usar propriedades do formsModule, lembrar de importá-lo <<<


~
Quando der erro de "não reconhecido por NgModule ou input, lembrar de colocar o FormsModule/HTTPModule dentro do imports em NgModule, ou no imports de onde ele for usado"
~
________________________
| COMPONENT SE DECLARA |
| MÓDULO SE IMPORTA    |
|______________________|

//está recebendo um valor do component pai para o component filho
@Input() 

//expondo valores através de um evento
@Output

> Ciclo de vida do component - Life Cycle Hooks
REVER AULA #15 E FAZER ANOTAÇÕES
- Métodos:
-> ngOnInit é um dos métodos mais usados, porque é geralmente dentro desse método que se faz a chamada para o servidor, pra obter os dados e mostrar no template
-> ngOnChanges também é um dos mais importantes, principalmente quando se trabalha com input properties, e esse muda
-> E o ngOnDestroy, que serve para liberar a memória, quando se está trabalhando com http e observables, e se destrói a inscrição que se faz no observable quando o component for destruído

=== Quando tem o input property usa-se o ngOnChanges, se não tem usa-se o ngOnInit

-----------------------------------------------------
AULA #18 7:05

> Ferramentas do Angular CLI
* ng lint
    Verfica se o projeto está de acordo com as boas práticas do style guide
* ng test
    Executa os testes jasmins, que são os testes unitários
* ng e2e  
    Teste end to end com Protractor

----------------------------------------------
>Jasmine
   - É uma biblioteca de bdd, ou seja, para escrever testes orientados a comportamento.
   - Aqui também pode usar o tdd
   - Olhando a documentação, contém códigos modelos para realizar os testes
* ng test
    Após realizar os testes, ele abre o navegador com o Karma, que é uma ferramenta de testes que permite executar cada linha de código do teste em diferentes browser (assim, pode-se emular e verificar a compatibilidade cross-browser da aplicação)

> Protractor
    - Ferramenta de teste para ferramenta de integração

> Para que serve o Angular CLI
    - Criar toda a estrutura do projeto
    - Gera página HTML inicial, arquivos TypeScript iniciais, arquivos CSS e arquivos de teste unitários
    - Cria arquivo package.json com todas as dependências do Angular 2
    - Instala todas as dependências do node (npm install)
    - Configura o Karma para executar os testes unitários com Jasmine
    - Configura Protractor para executar os testes end-to-end (e2e)
    - Inicializa um repositório git no projeto e faz commit inicial
    - Cria todos arquivos necessários para fazer o build da aplicação para produção

> Estrutura do package.json
    - Dependencies x DevDependencies
        -> Dependencies
            Dependências necessárias para executar a aplicação
        -> DevDependencies 
            Dependências necessárias para desenvolver a aplicação (não necessárias após o build de produção)
    -- Dependencies
        -> @angular/core 
            - pacote principal do framework Angular 2
            - Contém decorators e metadados, Component, Dirctive, injeção de dependência e os hooks de ciclo de vida do Component.
        -> @angular/common
            - Serviços, pipes e diretivas comuns (ex. ngIf, ngFor) fornecidas pelo time dev do angular
        -> @angular/compiler
            - Template de compilação do angular.
            - Entende o código dos templates e converte em código que faz a app ser executada e renderizada.
            - Desenvolvedores não interagem com esse pacote diretamente (apenas usa-se o seu código)
        -> @angular/forms
            - Contpem todo o código para construção de formulários do angular 2
        -> @angular/plataform-browser
            - Relacionado à manipulação do DOM
            - Contém todo o código relacionado ao DOM e ao browser, especialmente as partes que ajudam a renderizar o DOM
            - Esse pacote também contém o método para fazer o bootstrap da aplicação para buids de produção que pré-compila os templates
        -> @angular/plataform-browser-dynamic
            - Contém os Providers e o método para iniciar as aplicações que compilam templates no lado cliente
            - Não usa compilação offline
            - Usada para fazer bootstrap durante o desenvolvimento e exemplos plunker
        -> @angular/http
            - Fornece o cliente HTTP
            - É o que permite que se faça chamadas AJAX ou REST pra um servidor
        -> @angular/router
            - Classe de roteamento
            - Pra mudar de uma página ou não, para carregar de um template para outro, etc
    -- Dependencies Polyfills (bibliotecas auxiliares)
        -> core-js
            - biblioteca que permite compatibilidade de engines JS antigas com a especificação do ES 2015, ou seja, emula as funcionalidades do ES 2015 (ES6) e ES 7 em browsers que suportam somente ES5
        -> reflect-metadata
            - Dependência compartilhada entre o Angular e o compilador TypeScript. Permite o uso de decorators no código (annotations)
            - Permite ao dev fazer upgrade no TS sem precisar de fazer upgrade no Angular. E esse é o motivo dessa ser uma dependência da aplicação e não do Angular
        -> rxjs
            - Extensão para a especificação dos Observables (programação assíncrona) 
            - Reactive extensions for JS
            - São usadas principalmente na hora de fazer integração com o servidor, chamadas AJAX
        -> ts-helpers
            - Biblioteca auxiliar que permite otimização de código TS quando o mesmo é compilado para ES 5
            - Ex. tem momentos em que o código é compilado e é duplicado, ela tira essas duplicações
        -> zone.js
            - Extensão (plugins) útil para tarefas assíncronas (chamadas de Zones)   
    -- DevDependencies 
        -> dependências do Jasmine
        -> dependências do Protractor
        -> dependências do Karma
        etc.

> Gerando o build de produção
    - Onde vai ser feito o deploy (colocar no ar alguma aplicação que teve seu desenvolvimento concluído) pros usuários poderem usar a aplicação
    - Build de dev
        * ng build | ng build --dev
        -> Útil para integrar o código do Angular 2 com o projeto de backend (PHP, Java, .Net, Python,Ruby, etc)
        -> Código possível de debugar
        -> Arquivo main.bundle.js contém todo o código do projeto + css + HTML (legível)
    - Build de produção
        * ng build | ng build --prod
        -> Obfusca e minifica o código JS da aplicação
            (minifica para diminuir o tamanho do arquivo)
        -> css e templates HTML já minificados e incluídos em main.bundle.js
            A aplicação sempre será atualizada, toda vez que tiver uma nova versão
    ... instalando HTTP Server
        npm install http-server -g
        - Serve para testar código simples, sem a necessidade de ter um servidor a parte

> Instalando bibliotecas externas
    -> bootstrap, jquery e tether
        * npm install --save bootstrap@next
        --save: serve para salvar nas DevDependencies no package.json
        Passo1. Primeiro se escolhe qual versão do bootstrap/dist/css/bootstrap.css ou bootstrap.min.css (min de versão minificada)
          Também se escolhe o arquivo bootstrap/dist/bootstrap.js ou bootstrap.min.js 
        ^ Dois arquivos necesários para importar no projeto ^
        Passo2. Depois também vai na pasta bootstrap/dist/jquery/dist/jquery.js ou jquery.min.js
        Passo3. E bootstrap/dist/tether/dist
            (Tether é uma biblioteca que vai fazer o meio de campo entre jquery e bootstrap, pro código que será usado na aplicação
            )
    
    >>> dentro de angular-cli.json tem-se "scripts" e "styles", que é onde será colocado os estilos css e os scripts de js externo, e isso é para não ter que colocar imports dentro do index.html <<<
    
    -> Materialize 

> Diretivas
    - São uma forma de passar instruções para o template 
    -- ngFor
    <ul>
        <li *ngFor="let curso of cursos">{{ curso }}</li>
    </ul>
    - Components são diretivas com template
    "Crie um componente do Tipo (classe) especificado e renderize a view (template) desse componente nesse lugar"
    - Há dois tipos de diretivas:
        >> Estruturais
            ~ Interagem com a view e modificam a estrutura do DOM e/ou código HTML
            ~ Ex. ngFor e ngIf, ngSwitchCase
        >> De Atributos
            ~ Interagem com o elemento em que foram aplicadas
            ~ Ex. ng-classe, ng-style    

*ngIf
    - Não existe else, então o que se faz é negar as condições para ir formando o necessário
    - Exemplo em: projeto diretivas/diretiva-ngIf

>> NGIF X HIDDEN
    [hidden]="" 
        É recomendado o uso para árvore de elementos pequena
        É menos seguro, pois ainda assim mostra os elementos pelo console do navegador
    *ngIf=""
        É recomendado para árvore de elementos grades (muitas heranças)
        É mais seguro porque ele destrói o elemento que não for para ser mostrado
<<

*ngSwitch, *ngSwitchCase

> Conhecendo o * das diretivas
    Por trás do *, o angular cria um template, utiliza o property binding da diretiva e mostra o que se pede
    ex.1:
        <template [ngIf]="mostrarCursos">
            <div>Lista de cursos aqui</div>
        </template>    
        ou
        <div template="ngIf mostrarCursos">
            Lista de cursos aqui
        </div>    
    ex.2:
        <li template="ngFor let curso of cursos, let i = index">    
            {{ i + 1 }} - {{ curso }}
        </li>
        ou
        <template ngFor [ngForOf]="cursos" let-curso let-i="index">
            <li>{{ i + 1 }} - {{ curso }}</li>
        </template> 

>> ANOTAR SOBRE DIRETIVAS <<
- diretiva de atributo: ElementRef

> Criando uma diretiva, é como se fosse um component sem template. Então se trata apenas a parte lógica, a parte responsável pelo DOM
- Se o dev sentir a necessidade, ele pode criar um diretório para guardar todas as diretivas, pippes
- A diretiva também é declarada em declarators

| Quando se quer descobrir o elemento DOM a modificar, o caminho pode ser achado no navegador |
| usando F12, e dando um console.log() na variável que será usada para acesso desse elemento. |

